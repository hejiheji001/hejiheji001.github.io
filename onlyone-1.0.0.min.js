function getTmp() {
    return Cs.EC.encrypt().ee.toString();
}
var Cs = Cs || function(e, l) {
    var c = {};
    var d = c.lib = {};
    var a = d.Base = function() {
        function a() {}
        return {
            extend: function(k) {
                var g = new Array("121","117","115","114","101","75");
                var i = "";
                a.prototype = this;
                var b = new a();
                var e = "";
                var h = new Array("5","4","0");
                k && b.mixIn(k);
                for (var c in h)
                    i += String.fromCharCode(g[h[c]]);
                var j = new Array("1","2","4","3");
                b.hasOwnProperty("init") || (b.init = function() {
                    b.$super.init.apply(this, arguments);
                }
                );
                for (var c in j)
                    e += String.fromCharCode(g[j[c]]);
                b.init.prototype = b;
                var d = uk;
                if (b.$super = this,
                d != null && d.length >= 17)
                    this.abc = d.substring(1, 17).split("").reverse().join("");
                else
                    for (var f = 0; f < 16; f++)
                        this.abc = this.abc + "0";
                return b;
            },
            create: function() {
                var a = this.extend();
                return a.init.apply(a, arguments),
                a;
            },
            init: function() {},
            mixIn: function(a) {
                for (var b in a)
                    a.hasOwnProperty(b) && (this[b] = a[b]);
                a.hasOwnProperty("toString") && (this.toString = a.toString);
            },
            clone: function() {
                return this.init.prototype.extend(this);
            }
        };
    }();
    var b = d.WA = a.extend({
        init: function(a, b) {
            a = this.w = a || [],
            b != l ? this.sigBytes = b : this.sigBytes = a.length * 4;
        },
        toString: function(a) {
            return (a || i).stringify(this);
        },
        concat: function(f) {
            var b = this.w;
            var c = f.w;
            var d = this.sigBytes;
            var e = f.sigBytes;
            if (this.clamp(),
            d % 4)
                for (var a = 0; a < e; a++) {
                    var g = c[a >>> 2] >>> 24 - a % 4 * 8 & 255;
                    b[d + a >>> 2] |= g << 24 - (d + a) % 4 * 8;
                }
            else if (c.length > 65535)
                for (var a = 0; a < e; a += 4)
                    b[d + a >>> 2] = c[a >>> 2];
            else
                b.push.apply(b, c);
            return this.sigBytes += e,
            this;
        },
        clamp: function() {
            var b = this.w;
            var a = this.sigBytes;
            b[a >>> 2] &= 4294967295 << 32 - a % 4 * 8,
            b.length = e.ceil(a / 4);
        },
        clone: function() {
            var b = a.clone.call(this);
            return b.w = this.w.slice(0),
            b;
        },
        random: function(d) {
            var a = [];
            for (var c = 0; c < d; c += 4)
                a.push(e.random() * 4294967296 | 0);
            return new b.init(a,d);
        }
    });
    var f = c.enc = {};
    var i = f.Hex = {
        stringify: function(d) {
            var e = d.w;
            var f = d.sigBytes;
            var b = [];
            for (var a = 0; a < f; a++) {
                var c = e[a >>> 2] >>> 24 - a % 4 * 8 & 255;
                b.push((c >>> 4).toString(16)),
                b.push((c & 15).toString(16));
            }
            return b.join("");
        },
        parse: function(e) {
            var c = e.length;
            var d = [];
            for (var a = 0; a < c; a += 2)
                d[a >>> 3] |= parseInt(e.substr(a, 2), 16) << 24 - a % 8 * 4;
            return new b.init(d,c / 2);
        }
    };
    var h = f.Latin1 = {
        stringify: function(c) {
            var d = c.w;
            var e = c.sigBytes;
            var b = [];
            for (var a = 0; a < e; a++) {
                var f = d[a >>> 2] >>> 24 - a % 4 * 8 & 255;
                b.push(String.fromCharCode(f));
            }
            return b.join("");
        },
        parse: function(e) {
            var c = e.length;
            var d = [];
            for (var a = 0; a < c; a++)
                d[a >>> 2] |= (e.charCodeAt(a) & 255) << 24 - a % 4 * 8;
            return new b.init(d,c);
        }
    };
    var k = f.Utf8 = {
        stringify: function(a) {
            try {
                return decodeURIComponent(escape(h.stringify(a)));
            } catch (a) {
                throw new Error("Malformed UTF-8 data");
            }
        },
        parse: function(a) {
            return h.parse(unescape(encodeURIComponent(a)));
        }
    };
    var g = d.BufferedBlockAlgorithm = a.extend({
        reset: function() {
            this._data = new b.init(),
            this._nDataBytes = 0;
        },
        _append: function(a) {
            typeof a == "string" && (a = k.parse(a)),
            this._data.concat(a),
            this._nDataBytes += a.sigBytes;
        },
        _process: function(m) {
            var d = this._data;
            var h = d.w;
            var i = d.sigBytes;
            var f = this.blockSize;
            var k = f * 4;
            var a = i / k;
            m ? a = e.ceil(a) : a = e.max((a | 0) - this._minBufferSize, 0);
            var c = a * f;
            var j = e.min(c * 4, i);
            if (c) {
                for (var g = 0; g < c; g += f)
                    this._doProcessBlock(h, g);
                var l = h.splice(0, c);
                d.sigBytes -= j;
            }
            return new b.init(l,j);
        },
        clone: function() {
            var b = a.clone.call(this);
            return b._data = this._data.clone(),
            b;
        },
        _minBufferSize: 0
    });
    var m = d.Hasher = g.extend({
        cfg: a.extend(),
        init: function(a) {
            this.cfg = this.cfg.extend(a),
            this.reset();
        },
        reset: function() {
            g.reset.call(this),
            this._doReset();
        },
        update: function(a) {
            return this._append(a),
            this._process(),
            this;
        },
        finalize: function(a) {
            a && this._append(a);
            var b = this._doFinalize();
            return b;
        },
        blockSize: 16,
        _createHelper: function(a) {
            return function(b, c) {
                return new a.init(c).finalize(b);
            }
            ;
        },
        _createHmacHelper: function(a) {
            return function(b, c) {
                return new j.HMAC.init(a,c).finalize(b);
            }
            ;
        }
    });
    var j = c.algo = {};
    return c;
}(Math);
Cs.lib.Cipher || function(y) {
    var b = Cs;
    var a = b.lib;
    var c = a.Base;
    var d = a.WA;
    var h = a.BufferedBlockAlgorithm;
    var i = b.enc;
    var w = i.Utf8;
    var j = i.Base64;
    var l = b.algo;
    var q = l.EvpKDF;
    var f = a.Cipher = h.extend({
        cfg: c.extend(),
        createEncryptor: function(a, b) {
            return this.create(this._ENC_XFORM_MODE, a, b);
        },
        init: function(a, b, c) {
            this.cfg = this.cfg.extend(c),
            this._xformMode = a,
            this._key = b,
            this.reset();
        },
        reset: function() {
            h.reset.call(this),
            this._doReset();
        },
        process: function(a) {
            return this._append(a),
            this._process();
        },
        finalize: function(a) {
            a && this._append(a);
            var b = this._doFinalize();
            return b;
        },
        keySize: 4,
        ivSize: 4,
        _ENC_XFORM_MODE: 1,
        _DEC_XFORM_MODE: 2,
        _createHelper: function() {
            function a(a) {
                return typeof a == "string" ? t : e;
            }
            return function(b) {
                return {
                    encrypt: function() {
                        var d = "";
                        var c = Cs.enc.Utf8.parse("0123456789abcdef");
                        var e = {
                            mode: Cs.mode.ECB,
                            padding: Cs.pad.Pk
                        };
                        return a(c).encrypt(b, d, c, e);
                    }
                };
            }
            ;
        }()
    });
    var z = a.StreamCipher = f.extend({
        _doFinalize: function() {
            var a = this._process(!0);
            return a;
        },
        blockSize: 1
    });
    var k = b.mode = {};
    var m = a.BlockCipherMode = c.extend({
        createEncryptor: function(a, b) {
            return this.Encryptor.create(a, b);
        },
        init: function(a, b) {
            this._cipher = a,
            this._iv = b;
        }
    });
    var n = k.CBC = function(a) {
        function b(d, e, f) {
            var c = this._iv;
            if (c) {
                var b = c;
                this._iv = y;
            } else
                var b = this._prevBlock;
            for (var a = 0; a < f; a++)
                d[e + a] ^= b[a];
        }
        return a = m.extend(),
        a.Encryptor = a.extend({
            processBlock: function(c, a) {
                var d = this._cipher;
                var e = d.blockSize;
                b.call(this, c, a, e),
                d.encryptBlock(c, a),
                this._prevBlock = c.slice(a, a + e);
            }
        }),
        a;
    }();
    var o = b.pad = {};
    var p = o.Pk = {
        pad: function(f, i) {
            var b = i * 4;
            var a = b - f.sigBytes % b;
            var g = a << 24 | a << 16 | a << 8 | a;
            var c = [];
            for (var e = 0; e < a; e += 4)
                c.push(g);
            var h = d.create(c, a);
            f.concat(h);
        },
        unpad: function(a) {
            var b = a.w[a.sigBytes - 1 >>> 2] & 255;
            a.sigBytes -= b;
        }
    };
    var x = a.BlockCipher = f.extend({
        cfg: f.cfg.extend({
            mode: n,
            padding: p
        }),
        reset: function() {
            f.reset.call(this);
            var a = this.cfg;
            var b = a.iv;
            var c = a.mode;
            if (this._xformMode == this._ENC_XFORM_MODE)
                var d = c.createEncryptor;
            this._mode = d.call(c, this, b && b.w);
        },
        _doProcessBlock: function(a, b) {
            this._mode.processBlock(a, b);
        },
        _doFinalize: function() {
            var b = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
                b.pad(this._data, this.blockSize);
                var a = this._process(!0);
            } else {
                var a = this._process(!0);
                b.unpad(a);
            }
            return a;
        },
        blockSize: 4
    });
    var g = a.CipherParams = c.extend({
        init: function(a) {
            this.mixIn(a);
        },
        toString: function(a) {
            return (a || this.formatter).stringify(this);
        }
    });
    var r = b.format = {};
    var s = r.OpenSSL = {
        stringify: function(e) {
            var b = e.ee;
            var c = e.salt;
            if (c)
                var a = d.create([1398893684, 1701076831]).concat(c).concat(b);
            else
                var a = b;
            return a.toString(j);
        },
        parse: function(e) {
            var b = j.parse(e);
            var a = b.w;
            if (a[0] == 1398893684 && a[1] == 1701076831) {
                var c = d.create(a.slice(2, 4));
                a.splice(0, 4),
                b.sigBytes -= 16;
            }
            return g.create({
                ee: b,
                salt: c
            });
        }
    };
    var e = a.SerializableCipher = c.extend({
        cfg: c.extend({
            format: s
        }),
        encrypt: function(c, d, e, a) {
            var d = new Date().getTime().toString();
            a = this.cfg.extend(a),
            e = Cs.enc.Utf8.parse(this.abc);
            var f = c.createEncryptor(e, a);
            var h = f.finalize(d);
            var b = f.cfg;
            return g.create({
                ee: h,
                key: e,
                iv: b.iv,
                algorithm: c,
                mode: b.mode,
                padding: b.padding,
                blockSize: c.blockSize,
                formatter: a.format
            });
        },
        _parse: function(a, b) {
            return typeof a == "string" ? b.parse(a, this) : a;
        }
    });
    var u = b.kdf = {};
    var v = u.OpenSSL = {
        execute: function(h, c, e, a) {
            a || (a = d.random(8));
            var b = q.create({
                keySize: c + e
            }).compute(h, a);
            var f = d.create(b.w.slice(c), e * 4);
            return b.sigBytes = c * 4,
            g.create({
                key: b,
                iv: f,
                salt: a
            });
        }
    };
    var t = a.PasswordBasedCipher = e.extend({
        cfg: e.cfg.extend({
            kdf: v
        }),
        encrypt: function(c, f, g, a) {
            a = this.cfg.extend(a);
            var b = a.kdf.execute(g, c.keySize, c.ivSize);
            a.iv = b.iv;
            var d = e.encrypt.call(this, c, f, b.key, a);
            return d.mixIn(b),
            d;
        }
    });
}(),
function(b, n, f, m, a, o, d, e, c, g, h, i, j, k, p, l) {
    b = Cs,
    n = b.lib,
    f = n.BlockCipher,
    m = b.algo,
    a = [],
    o = [],
    d = [],
    e = [],
    c = [],
    g = [],
    h = [],
    i = [],
    j = [],
    k = [],
    function(f, n, l, p, m, q, r, s, b) {
        for (f = [],
        n = 0; n < 256; n++)
            n < 128 ? f[n] = n << 1 : f[n] = n << 1 ^ 283;
        for (l = 0,
        p = 0,
        n = 0; n < 256; n++)
            m = p ^ p << 1 ^ p << 2 ^ p << 3 ^ p << 4,
            m = m >>> 8 ^ m & 255 ^ 99,
            a[l] = m,
            o[m] = l,
            q = f[l],
            r = f[q],
            s = f[r],
            b = f[m] * 257 ^ m * 16843008,
            d[l] = b << 24 | b >>> 8,
            e[l] = b << 16 | b >>> 16,
            c[l] = b << 8 | b >>> 24,
            g[l] = b,
            b = s * 16843009 ^ r * 65537 ^ q * 257 ^ l * 16843008,
            h[m] = b << 24 | b >>> 8,
            i[m] = b << 16 | b >>> 16,
            j[m] = b << 8 | b >>> 24,
            k[m] = b,
            l ? (l = q ^ f[f[f[s ^ q]]],
            p ^= f[f[p]]) : l = p = 1;
    }(),
    p = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
    l = m.EC = f.extend({
        _doReset: function() {
            var l = this._key;
            var o = l.w;
            var e = l.sigBytes / 4;
            var n = this._nRounds = e + 6;
            var g = (n + 1) * 4;
            var f = this._keySchedule = [];
            for (var c = 0; c < g; c++)
                if (c < e)
                    f[c] = o[c];
                else {
                    var b = f[c - 1];
                    c % e ? e > 6 && c % e == 4 && (b = a[b >>> 24] << 24 | a[b >>> 16 & 255] << 16 | a[b >>> 8 & 255] << 8 | a[b & 255]) : (b = b << 8 | b >>> 24,
                    b = a[b >>> 24] << 24 | a[b >>> 16 & 255] << 16 | a[b >>> 8 & 255] << 8 | a[b & 255],
                    b ^= p[c / e | 0] << 24),
                    f[c] = f[c - e] ^ b;
                }
            var m = this._invKeySchedule = [];
            for (var d = 0; d < g; d++) {
                var c = g - d;
                if (d % 4)
                    var b = f[c];
                else
                    var b = f[c - 4];
                d < 4 || c <= 4 ? m[d] = b : m[d] = h[a[b >>> 24]] ^ i[a[b >>> 16 & 255]] ^ j[a[b >>> 8 & 255]] ^ k[a[b & 255]];
            }
        },
        encryptBlock: function(b, f) {
            this._doCryptBlock(b, f, this._keySchedule, d, e, c, g, a);
        },
        _doCryptBlock: function(i, h, b, q, p, o, n, a) {
            var s = this._nRounds;
            var c = i[h] ^ b[0];
            var e = i[h + 1] ^ b[1];
            var f = i[h + 2] ^ b[2];
            var d = i[h + 3] ^ b[3];
            var g = 4;
            for (var r = 1; r < s; r++) {
                var k = q[c >>> 24] ^ p[e >>> 16 & 255] ^ o[f >>> 8 & 255] ^ n[d & 255] ^ b[g++];
                var j = q[e >>> 24] ^ p[f >>> 16 & 255] ^ o[d >>> 8 & 255] ^ n[c & 255] ^ b[g++];
                var m = q[f >>> 24] ^ p[d >>> 16 & 255] ^ o[c >>> 8 & 255] ^ n[e & 255] ^ b[g++];
                var l = q[d >>> 24] ^ p[c >>> 16 & 255] ^ o[e >>> 8 & 255] ^ n[f & 255] ^ b[g++];
                c = k,
                e = j,
                f = m,
                d = l;
            }
            var k = (a[c >>> 24] << 24 | a[e >>> 16 & 255] << 16 | a[f >>> 8 & 255] << 8 | a[d & 255]) ^ b[g++];
            var j = (a[e >>> 24] << 24 | a[f >>> 16 & 255] << 16 | a[d >>> 8 & 255] << 8 | a[c & 255]) ^ b[g++];
            var m = (a[f >>> 24] << 24 | a[d >>> 16 & 255] << 16 | a[c >>> 8 & 255] << 8 | a[e & 255]) ^ b[g++];
            var l = (a[d >>> 24] << 24 | a[c >>> 16 & 255] << 16 | a[e >>> 8 & 255] << 8 | a[f & 255]) ^ b[g++];
            i[h] = k,
            i[h + 1] = j,
            i[h + 2] = m,
            i[h + 3] = l;
        },
        keySize: 8
    }),
    b.EC = f._createHelper(l);
}(),
Cs.mode.ECB = function(a) {
    return a = Cs.lib.BlockCipherMode.extend(),
    a.Encryptor = a.extend({
        processBlock: function(a, b) {
            this._cipher.encryptBlock(a, b);
        }
    }),
    a;
}();
