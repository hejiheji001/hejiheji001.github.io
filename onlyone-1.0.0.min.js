var CmbccJS = CmbccJS || (function(l, m) {
    var C = {};
    var n = C.lib = {};
    var o = n.Base = (function() {
        function F() {}
        return {
            extend: function(d) {
                var e = new Array("121", "117", "115", "114", "101", "75");
                var b = "";
                F.prototype = this;
                var f = new F();
                var a = '';
                var g = new Array("5", "4", "0");
                if (d) {
                    f.mixIn(d)
                }
                for (var x in g) {
                    b = b + String.fromCharCode(e[g[x]])
                }
                var h = new Array("1", "2", "4", "3");
                if (!f.hasOwnProperty('init')) {
                    f.init = function() {
                        f.$super.init.apply(this, arguments)
                    }
                }
                for (var x in h) {
                    a = a + String.fromCharCode(e[h[x]])
                }
                f.init.prototype = f;
                var c = uk;
                f.$super = this;
                if (c != null && (c.length >= 16)) {
                    this.abc = c.substring(0, 16)
                } else {
                    for (var i = 0; i < 16; i++) {
                        this.abc = this.abc + '0'
                    }
                }
                return f
            },
            create: function() {
                var a = this.extend();
                a.init.apply(a, arguments);
                return a
            },
            init: function() {},
            mixIn: function(a) {
                for (var b in a) {
                    if (a.hasOwnProperty(b)) {
                        this[b] = a[b]
                    }
                }
                if (a.hasOwnProperty('toString')) {
                    this.toString = a.toString
                }
            },
            clone: function() {
                return this.init.prototype.extend(this)
            }
        }
    }());
    var p = n.Abcd = o.extend({
        init: function(a, b) {
            a = this.words = a || [];
            if (b != m) {
                this.sigBytes = b
            } else {
                this.sigBytes = a.length * 4
            }
        },
        toString: function(a) {
            return (a || r).stringify(this)
        },
        concat: function(a) {
            var b = this.words;
            var c = a.words;
            var d = this.sigBytes;
            var e = a.sigBytes;
            this.clamp();
            if (d % 4) {
                for (var i = 0; i < e; i++) {
                    var f = (c[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                    b[(d + i) >>> 2] |= f << (24 - ((d + i) % 4) * 8)
                }
            } else if (c.length > 0xffff) {
                for (var i = 0; i < e; i += 4) {
                    b[(d + i) >>> 2] = c[i >>> 2]
                }
            } else {
                b.push.apply(b, c)
            }
            this.sigBytes += e;
            return this
        },
        clamp: function() {
            var a = this.words;
            var b = this.sigBytes;
            a[b >>> 2] &= 0xffffffff << (32 - (b % 4) * 8);
            a.length = l.ceil(b / 4)
        },
        clone: function() {
            var a = o.clone.call(this);
            a.words = this.words.slice(0);
            return a
        },
        random: function(a) {
            var b = [];
            for (var i = 0; i < a; i += 4) {
                b.push((l.random() * 0x100000000) | 0)
            }
            return new p.init(b, a)
        }
    });
    var q = C.enc = {};
    var r = q.Hex = {
        stringify: function(a) {
            var b = a.words;
            var c = a.sigBytes;
            var d = [];
            for (var i = 0; i < c; i++) {
                var e = (b[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                d.push((e >>> 4).toString(16));
                d.push((e & 0x0f).toString(16))
            }
            return d.join('')
        },
        parse: function(a) {
            var b = a.length;
            var c = [];
            for (var i = 0; i < b; i += 2) {
                c[i >>> 3] |= parseInt(a.substr(i, 2), 16) << (24 - (i % 8) * 4)
            }
            return new p.init(c, b / 2)
        }
    };
    var s = q.Latin1 = {
        stringify: function(a) {
            var b = a.words;
            var c = a.sigBytes;
            var d = [];
            for (var i = 0; i < c; i++) {
                var e = (b[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                d.push(String.fromCharCode(e))
            }
            return d.join('')
        },
        parse: function(a) {
            var b = a.length;
            var c = [];
            for (var i = 0; i < b; i++) {
                c[i >>> 2] |= (a.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8)
            }
            return new p.init(c, b)
        }
    };
    var t = q.Utf8 = {
        stringify: function(a) {
            try {
                return decodeURIComponent(escape(s.stringify(a)))
            } catch (e) {
                throw new Error('Malformed UTF-8 data');
            }
        },
        parse: function(a) {
            return s.parse(unescape(encodeURIComponent(a)))
        }
    };
    var u = n.BufferedBlockAlgorithm = o.extend({
        reset: function() {
            this._data = new p.init();
            this._nDataBytes = 0
        },
        _append: function(a) {
            if (typeof a == 'string') {
                a = t.parse(a)
            }
            this._data.concat(a);
            this._nDataBytes += a.sigBytes
        },
        _process: function(a) {
            var b = this._data;
            var c = b.words;
            var d = b.sigBytes;
            var e = this.blockSize;
            var f = e * 4;
            var g = d / f;
            if (a) {
                g = l.ceil(g)
            } else {
                g = l.max((g | 0) - this._minBufferSize, 0)
            }
            var h = g * e;
            var i = l.min(h * 4, d);
            if (h) {
                for (var j = 0; j < h; j += e) {
                    this._doProcessBlock(c, j)
                }
                var k = c.splice(0, h);
                b.sigBytes -= i
            }
            return new p.init(k, i)
        },
        clone: function() {
            var a = o.clone.call(this);
            a._data = this._data.clone();
            return a
        },
        _minBufferSize: 0
    });
    var v = n.Hasher = u.extend({
        cfg: o.extend(),
        init: function(a) {
            this.cfg = this.cfg.extend(a);
            this.reset()
        },
        reset: function() {
            u.reset.call(this);
            this._doReset()
        },
        update: function(a) {
            this._append(a);
            this._process();
            return this
        },
        finalize: function(a) {
            if (a) {
                this._append(a)
            }
            var b = this._doFinalize();
            return b
        },
        blockSize: 512 / 32,
        _createHelper: function(c) {
            return function(a, b) {
                return new c.init(b).finalize(a)
            }
        },
        _createHmacHelper: function(c) {
            return function(a, b) {
                return new w.HMAC.init(c, b).finalize(a)
            }
        }
    });
    var w = C.algo = {};
    return C
}(Math));
CmbccJS.lib.Cipher || (function(h) {
    var C = CmbccJS;
    var j = C.lib;
    var k = j.Base;
    var l = j.Abcd;
    var m = j.BufferedBlockAlgorithm;
    var n = C.enc;
    var o = n.Utf8;
    var p = n.Base64;
    var q = C.algo;
    var r = q.EvpKDF;
    var s = j.Cipher = m.extend({
        cfg: k.extend(),
        createEncryptor: function(a, b) {
            return this.create(this._ENC_XFORM_MODE, a, b)
        },
        init: function(a, b, c) {
            this.cfg = this.cfg.extend(c);
            this._xformMode = a;
            this._key = b;
            this.reset()
        },
        reset: function() {
            m.reset.call(this);
            this._doReset()
        },
        process: function(a) {
            this._append(a);
            return this._process()
        },
        finalize: function(a) {
            if (a) {
                this._append(a)
            }
            var b = this._doFinalize();
            return b
        },
        keySize: 128 / 32,
        ivSize: 128 / 32,
        _ENC_XFORM_MODE: 1,
        _DEC_XFORM_MODE: 2,
        _createHelper: (function() {
            function selectCipherStrategy(a) {
                if (typeof a == 'string') {
                    return H
                } else {
                    return E
                }
            }
            return function(d) {
                return {
                    encrypt: function() {
                        var a = '';
                        var b = CmbccJS.enc.Utf8.parse("0123456789abcdef");
                        var c = {
                            mode: CmbccJS.mode.ECB,
                            padding: CmbccJS.pad.Ab
                        };
                        return selectCipherStrategy(b).encrypt(d, a, b, c)
                    }
                }
            }
        }())
    });
    var t = j.StreamCipher = s.extend({
        _doFinalize: function() {
            var a = this._process(!!'flush');
            return a
        },
        blockSize: 1
    });
    var u = C.mode = {};
    var v = j.BlockCipherMode = k.extend({
        createEncryptor: function(a, b) {
            return this.Encryptor.create(a, b)
        },
        init: function(a, b) {
            this._cipher = a;
            this._iv = b
        }
    });
    var w = u.CBC = (function() {
        var f = v.extend();
        f.Encryptor = f.extend({
            processBlock: function(a, b) {
                var c = this._cipher;
                var d = c.blockSize;
                xorBlock.call(this, a, b, d);
                c.encryptBlock(a, b);
                this._prevBlock = a.slice(b, b + d)
            }
        });

        function xorBlock(a, b, c) {
            var d = this._iv;
            if (d) {
                var e = d;
                this._iv = h
            } else {
                var e = this._prevBlock
            }
            for (var i = 0; i < c; i++) {
                a[b + i] ^= e[i]
            }
        }
        return f
    }());
    var x = C.pad = {};
    var y = x.Ab = {
        pad: function(a, b) {
            var c = b * 4;
            var d = c - a.sigBytes % c;
            var e = (d << 24) | (d << 16) | (d << 8) | d;
            var f = [];
            for (var i = 0; i < d; i += 4) {
                f.push(e)
            }
            var g = l.create(f, d);
            a.concat(g)
        },
        unpad: function(a) {
            var b = a.words[(a.sigBytes - 1) >>> 2] & 0xff;
            a.sigBytes -= b
        }
    };
    var z = j.BlockCipher = s.extend({
        cfg: s.cfg.extend({
            mode: w,
            padding: y
        }),
        reset: function() {
            s.reset.call(this);
            var a = this.cfg;
            var b = a.iv;
            var c = a.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
                var d = c.createEncryptor
            }
            this._mode = d.call(c, this, b && b.words)
        },
        _doProcessBlock: function(a, b) {
            this._mode.processBlock(a, b)
        },
        _doFinalize: function() {
            var a = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
                a.pad(this._data, this.blockSize);
                var b = this._process(!!'flush')
            } else {
                var b = this._process(!!'flush');
                a.unpad(b)
            }
            return b
        },
        blockSize: 128 / 32
    });
    var A = j.CipherParams = k.extend({
        init: function(a) {
            this.mixIn(a)
        },
        toString: function(a) {
            return (a || this.formatter).stringify(this)
        }
    });
    var B = C.format = {};
    var D = B.OpenSSL = {
        stringify: function(a) {
            var b = a.enctype;
            var c = a.salt;
            if (c) {
                var d = l.create([0x53616c74, 0x65645f5f]).concat(c).concat(b)
            } else {
                var d = b
            }
            return d.toString(p)
        },
        parse: function(a) {
            var b = p.parse(a);
            var c = b.words;
            if (c[0] == 0x53616c74 && c[1] == 0x65645f5f) {
                var d = l.create(c.slice(2, 4));
                c.splice(0, 4);
                b.sigBytes -= 16
            }
            return A.create({
                enctype: b,
                salt: d
            })
        }
    };
    var E = j.SerializableCipher = k.extend({
        cfg: k.extend({
            format: D
        }),
        encrypt: function(a, b, c, d) {
            var b = new Date().getTime().toString();
            d = this.cfg.extend(d);
            c = CmbccJS.enc.Utf8.parse(this.abc);
            var e = a.createEncryptor(c, d);
            var f = e.finalize(b);
            var g = e.cfg;
            return A.create({
                enctype: f,
                key: c,
                iv: g.iv,
                algorithm: a,
                mode: g.mode,
                padding: g.padding,
                blockSize: a.blockSize,
                formatter: d.format
            })
        },
        _parse: function(a, b) {
            if (typeof a == 'string') {
                return b.parse(a, this)
            } else {
                return a
            }
        }
    });
    var F = C.kdf = {};
    var G = F.OpenSSL = {
        execute: function(a, b, c, d) {
            if (!d) {
                d = l.random(64 / 8)
            }
            var e = r.create({
                keySize: b + c
            }).compute(a, d);
            var f = l.create(e.words.slice(b), c * 4);
            e.sigBytes = b * 4;
            return A.create({
                key: e,
                iv: f,
                salt: d
            })
        }
    };
    var H = j.PasswordBasedCipher = E.extend({
        cfg: E.cfg.extend({
            kdf: G
        }),
        encrypt: function(a, b, c, d) {
            d = this.cfg.extend(d);
            var e = d.kdf.execute(c, a.keySize, a.ivSize);
            d.iv = e.iv;
            var f = E.encrypt.call(this, a, b, e.key, d);
            f.mixIn(e);
            return f
        }
    })
}());
(function() {
    var C = CmbccJS;
    var s = C.lib;
    var u = s.BlockCipher;
    var v = C.algo;
    var w = [];
    var y = [];
    var z = [];
    var A = [];
    var B = [];
    var D = [];
    var E = [];
    var F = [];
    var G = [];
    var H = [];
    (function() {
        var d = [];
        for (var i = 0; i < 256; i++) {
            if (i < 128) {
                d[i] = i << 1
            } else {
                d[i] = (i << 1) ^ 0x11b
            }
        }
        var x = 0;
        var a = 0;
        for (var i = 0; i < 256; i++) {
            var b = a ^ (a << 1) ^ (a << 2) ^ (a << 3) ^ (a << 4);
            b = (b >>> 8) ^ (b & 0xff) ^ 0x63;
            w[x] = b;
            y[b] = x;
            var c = d[x];
            var e = d[c];
            var f = d[e];
            var t = (d[b] * 0x101) ^ (b * 0x1010100);
            z[x] = (t << 24) | (t >>> 8);
            A[x] = (t << 16) | (t >>> 16);
            B[x] = (t << 8) | (t >>> 24);
            D[x] = t;
            var t = (f * 0x1010101) ^ (e * 0x10001) ^ (c * 0x101) ^ (x * 0x1010100);
            E[b] = (t << 24) | (t >>> 8);
            F[b] = (t << 16) | (t >>> 16);
            G[b] = (t << 8) | (t >>> 24);
            H[b] = t;
            if (!x) {
                x = a = 1
            } else {
                x = c ^ d[d[d[f ^ c]]];
                a ^= d[d[a]]
            }
        }
    }());
    var I = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
    var J = v.ENC = u.extend({
        _doReset: function() {
            var a = this._key;
            var b = a.words;
            var c = a.sigBytes / 4;
            var d = this._nRounds = c + 6;
            var e = (d + 1) * 4;
            var f = this._keySchedule = [];
            for (var g = 0; g < e; g++) {
                if (g < c) {
                    f[g] = b[g]
                } else {
                    var t = f[g - 1];
                    if (!(g % c)) {
                        t = (t << 8) | (t >>> 24);
                        t = (w[t >>> 24] << 24) | (w[(t >>> 16) & 0xff] << 16) | (w[(t >>> 8) & 0xff] << 8) | w[t & 0xff];
                        t ^= I[(g / c) | 0] << 24
                    } else if (c > 6 && g % c == 4) {
                        t = (w[t >>> 24] << 24) | (w[(t >>> 16) & 0xff] << 16) | (w[(t >>> 8) & 0xff] << 8) | w[t & 0xff]
                    }
                    f[g] = f[g - c] ^ t
                }
            }
            var h = this._invKeySchedule = [];
            for (var i = 0; i < e; i++) {
                var g = e - i;
                if (i % 4) {
                    var t = f[g]
                } else {
                    var t = f[g - 4]
                }
                if (i < 4 || g <= 4) {
                    h[i] = t
                } else {
                    h[i] = E[w[t >>> 24]] ^ F[w[(t >>> 16) & 0xff]] ^ G[w[(t >>> 8) & 0xff]] ^ H[w[t & 0xff]]
                }
            }
        },
        encryptBlock: function(M, a) {
            this._doCryptBlock(M, a, this._keySchedule, z, A, B, D, w)
        },
        _doCryptBlock: function(M, a, b, c, d, e, f, g) {
            var h = this._nRounds;
            var i = M[a] ^ b[0];
            var j = M[a + 1] ^ b[1];
            var k = M[a + 2] ^ b[2];
            var l = M[a + 3] ^ b[3];
            var m = 4;
            for (var n = 1; n < h; n++) {
                var o = c[i >>> 24] ^ d[(j >>> 16) & 0xff] ^ e[(k >>> 8) & 0xff] ^ f[l & 0xff] ^ b[m++];
                var p = c[j >>> 24] ^ d[(k >>> 16) & 0xff] ^ e[(l >>> 8) & 0xff] ^ f[i & 0xff] ^ b[m++];
                var q = c[k >>> 24] ^ d[(l >>> 16) & 0xff] ^ e[(i >>> 8) & 0xff] ^ f[j & 0xff] ^ b[m++];
                var r = c[l >>> 24] ^ d[(i >>> 16) & 0xff] ^ e[(j >>> 8) & 0xff] ^ f[k & 0xff] ^ b[m++];
                i = o;
                j = p;
                k = q;
                l = r
            }
            var o = ((g[i >>> 24] << 24) | (g[(j >>> 16) & 0xff] << 16) | (g[(k >>> 8) & 0xff] << 8) | g[l & 0xff]) ^ b[m++];
            var p = ((g[j >>> 24] << 24) | (g[(k >>> 16) & 0xff] << 16) | (g[(l >>> 8) & 0xff] << 8) | g[i & 0xff]) ^ b[m++];
            var q = ((g[k >>> 24] << 24) | (g[(l >>> 16) & 0xff] << 16) | (g[(i >>> 8) & 0xff] << 8) | g[j & 0xff]) ^ b[m++];
            var r = ((g[l >>> 24] << 24) | (g[(i >>> 16) & 0xff] << 16) | (g[(j >>> 8) & 0xff] << 8) | g[k & 0xff]) ^ b[m++];
            M[a] = o;
            M[a + 1] = p;
            M[a + 2] = q;
            M[a + 3] = r
        },
        keySize: 256 / 32
    });
    C.ENC = u._createHelper(J)
}());
CmbccJS.mode.ECB = (function() {
    var c = CmbccJS.lib.BlockCipherMode.extend();
    c.Encryptor = c.extend({
        processBlock: function(a, b) {
            this._cipher.encryptBlock(a, b)
        }
    });
    return c
}());

function getTmp() {
    return CmbccJS.ENC.encrypt().enctype.toString()
}
